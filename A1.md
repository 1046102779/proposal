HTTP CONNECT Proxy Support
--------------------------
* Author(s): Mark D. Roth (roth@google.com), Eric Anderson (ejona@google.com)
* Approver: a11r
* Status: Draft
* Implemented in: (C-core and Java are in progress)
* Last updated: 2017-01-18
* Discussion at: <google group thread> (filled after thread exists)

## Abstract

Describes what types of TCP-level proxy setups gRPC will support and
how those setups interact with load balancing.

## Background

It may be useful to read the following docs before this one:

- [gRPC load balancing](https://github.com/grpc/grpc/blob/master/doc/load-balancing.md)
- [gRPC name resolution](https://github.com/grpc/grpc/blob/master/doc/naming.md)
- [gRPC service config](https://github.com/grpc/grpc/blob/master/doc/service_config.md)

A TCP-level proxy is one that does not know anything about gRPC.
It accepts a TCP connection from a client, creates a new TCP connection
to another server, and forwards all bytes from the client to the server,
without actually understanding anything about the contents of those bytes.

Note that load-balancing within gRPC happens on a per-call basis, not
a per-connection basis.  Because of this, use of a TCP-level proxy may
limit the ability to do load balancing in some environments.

### Related Proposals: 

N/A

## Proposal

gRPC will support TCP-level proxies via the HTTP CONNECT request,
defined in [RFC-2817](https://tools.ietf.org/html/rfc2817).

We are aware of the following use-cases for TCP-level proxying with gRPC:

1. A corp environment where all traffic outbound to the internet must go
   through a proxy.  This environment has the following properties:
   - DNS resolution of external names does not work (i.e., all
     resolution must be done via the proxy).
   - *All* requests must go through the proxy, both for internal and
     external servers.
   - This environment is generally triggered by some centralized signal,
     such as the `http_proxy` environment variable or the Java registry.

2. A partially protected environment, where access to certain addresses
   must go through a proxy.  This environment has the following
   properties:
   - DNS resolution of protected servers works normally.
   - Only requests for certain hosts must go through the proxy.
     Requests to other servers work without the proxy.
   - Custom logic is used to determine which hosts the proxy will be
     used for.

We propose the following functionality to support these two cases:

- For case 1, the client channel code will check for the existence of the
  `http_proxy` environment variable (or equivalent signal).  If that
  signal is present, the client channel code will do the following:
  - Ask the resolver to resolve the proxy name instead of the server name
    requested via the client API.  (Note that this will cause us to
    create a single subchannel to the proxy, as opposed to one
    subchannel for each backend server.)
  - Add state (e.g., a channel argument in C-core) requesting that the
    subchannel code (see below) send an HTTP CONNECT request for the
    server name requested via the client API.

- For case 2, in the subchannel, before we connect to the target address,
  we will call a new *proxy mapper* hook, which will allow selectively
  requesting the use of a proxy based on the address to which the
  subchannel is going to connect.  If a proxy is to be used, the mapper
  will return the proxy address (which the subchannel will connect to
  instead of the address returned by the resolver) and some additional
  state (e.g., a channel argument in C-core) requesting that the
  subchannel send an HTTP CONNECT request for the original subchannel
  address.  Note that in this case, the server name used in the HTTP
  CONNECT request will be an IP address and port, not a hostname (i.e.,
  we are not relying on the proxy to do DNS resolution for us).

- When the subchannel establishes a new connection to a proxy, it will
  optionally (based on the state added in one of the two steps above)
  send an HTTP CONNECT request indicating the server it needs to connect to.

Note that in case 1, because the client cannot know the set of server
addresses, it is impossible to use the normal gRPC per-call load balancing.
It *is* possible to do load balancing on a per-connection basis, but
that may not spread out the load evenly if different clients impose a
different amount of load.

In contrast, in case 2, it *is* possible to do the normal gRPC per-call
load balancing, because the client does know the set of server
addresses.  The fact that the connections to those individual addresses
go through a TCP-level proxy does not interfere with the client opening
a separate subchannel to each address.

Also, note that in case 1, the client will not have access to the
service config for the server name.  This is not a problem in case 2.

## Rationale

The proposed design allows two different ways of triggering use of the
HTTP CONNECT handshaker code, which addresses the needs of both
environments described above.

There have also been discussions about how to do proxying for an
environment where a service is accessible over the internet but its
internal architecture (e.g., DNS names or server addresses) should not
be exposed publicly.  In this case, it is impossible to support per-call
load balancing via a TCP-level proxy, so we do not recommend its use.
Instead, we suggest the use of a gRPC-level proxy, where the proxy
natively speaks gRPC.  The idea is that the proxy accepts a gRPC request
from the external client and then uses its own client on the internal
side, which does the name resolution and load balancing internally to
the backend servers.

## Implementation

In C-core, the HTTP CONNECT handshaker has already been implemented.
The following additional changes are pending:

- grpc/grpc#9383 (changes HTTP CONNECT handshaker to be triggered via
  channel args)
- grpc/grpc#9372 (adds proxy mapper hook)

## Open issues (if applicable)

N/A
