HTTP CONNECT Proxy Support
--------------------------
* Author(s): Mark D. Roth (roth@google.com), Eric Anderson (ejona@google.com)
* Approver: a11r
* Status: Draft
* Implemented in: C-core (Java is in progress)
* Last updated: 2017-01-25
* Discussion at: https://groups.google.com/d/topic/grpc-io/zG7iYpDw6lk/discussion

## Abstract

Describes what types of TCP-level proxy setups gRPC will support and
how those setups interact with client-side per-call load balancing
policies (e.g., `grpclb` or `round_robin`).

## Background

It may be useful to read the following docs before this one:

- [gRPC load balancing](https://github.com/grpc/grpc/blob/master/doc/load-balancing.md)
- [gRPC name resolution](https://github.com/grpc/grpc/blob/master/doc/naming.md)
- [gRPC service config](https://github.com/grpc/grpc/blob/master/doc/service_config.md)

A TCP-level proxy is one that does not know anything about gRPC.
It accepts a TCP connection from a client, creates a new TCP connection
to another server, and forwards all bytes from the client to the server,
without actually understanding anything about the contents of those bytes.

Note that client-side per-call load-balancing within gRPC requires knowing
the addresses of the backends. Because of this, use of a TCP-level proxy
may limit the ability to do client-side per-call load balacing in some
environments.

### Related Proposals: 

N/A

## Proposal

gRPC will support TCP-level proxies via the HTTP CONNECT request,
defined in [RFC-2817](https://tools.ietf.org/html/rfc2817).

We are aware of the following use-cases for TCP-level proxying with gRPC:

1. A corp environment where all outbound traffic must go through a proxy.
   This environment has the following properties:
   - Name resolution of external names does not work (i.e., all
     resolution must be done via the proxy).
   - This environment is generally triggered by some centralized signal,
     such as the `http_proxy` environment variable or Java system
     properties.  (Note that this will actually send *all* connections
     through the proxy, not just outbound traffic, even though the
     real goal in this environment is just to use the proxy for the
     outbound traffic.  For applications that don't need to talk to
     internal servers, that's sufficient.)

2. A partially protected environment, where access to certain addresses
   must go through a proxy.  This environment has the following
   properties:
   - Name resolution of protected servers works normally.
   - Only requests for certain hosts must go through the proxy.
     Requests to other servers work without the proxy.
   - Custom logic is used to determine which hosts the proxy will be
     used for.

3. An environment where a service is accessible from the Internet but
   its internal architecture should not be exposed publicly.  This
   environment has the following properties:
   - Name resolution of internal names does not work externally (i.e.,
     all internal resolution must be done via the proxy).
   - Only requests for services behind the proxy will go through it.

We propose the following functionality to support these use cases:

- We will have some internal state (e.g., a channel arg in C-core) that
  both triggers the use of the HTTP CONNECT handshaker and specifies the
  argument to be used in the CONNECT request.

- For case 1, the client channel code will check for the existence of the
  `http_proxy` environment variable (or equivalent signal).  If that
  signal is present, the client channel code will do the following:
  - Ask the resolver to resolve the proxy name instead of the server name
    requested via the client API.  (Note that this will cause us to
    create a single subchannel to the proxy, as opposed to one
    subchannel for each backend server.)
  - Add the state described above triggering the use of the HTTP CONNECT
    handshaker, with the argument set to the server name requested via
    the client API.

- For cases 2 and 3, before each connection is made, application code
  can dynamically choose whether to use HTTP CONNECT and to which proxy
  based on the server name and/or server address.
  - In C-core, this will be implemented as follows: In the subchannel,
    before we connect to the target address, we will call a new *proxy
    mapper* hook, which will allow selectively requesting the use
    of a proxy based on the address to which the subchannel is going
    to connect.  If a proxy is to be used, the mapper will return the
    proxy address (which the subchannel will connect to instead of the
    address returned by the resolver) and add the additional state
    described above to trigger the use of the HTTP CONNECT handshaker,
    with the argument set to the original subchannel address.  Note that
    in this case, the server name used in the HTTP CONNECT request will
    be an IP address and port, not a hostname (i.e., we are not relying
    on the proxy to do name resolution for us).

Note that in case 1, because the client cannot know the set of server
addresses, it is impossible to use the normal gRPC client-side per-call
load balancing.  It *is* possible to do load balancing on a per-connection
basis, but that may not spread out the load evenly if different clients
impose a different amount of load.  (Note that even if we established
multiple connections to the proxy, we would have no guarantee that each
connection would go to a different backend server.)

In contrast, in case 2, it *is* possible to do the normal gRPC client-side
per-call load balancing, because the client does know the set of server
addresses.  The fact that the connections to those individual addresses
go through a TCP-level proxy does not interfere with the client opening
a separate subchannel to each address.

Case 3 is similar to case 1 in that the resolver cannot return the actual
addresses of the servers.  However, we (ab)use the gRPC load-balancing
design to work around this, so that it looks more like case 2.  In this
case, there will be an external name service record for the server name
that points to the IP address of the proxy and has the `is_balancer`
bit set.  (Note: We have not yet designed how that bit will be encoded
in DNS, but that will be the subject of a separate gRFC.)  The proxy
mapper implementation will then have to detect two types of addresses:

- When it sees the proxy address, it will set the HTTP CONNECT argument to
  the original server name (which will cause the proxy to establish a
  connection to one of the load balancers).
- When it sees any internal address (i.e., the addresses returned by
  the load balancer), it will replace it with the proxy address and set
  the HTTP CONNECT argument to the internal address.

Note that this will work only if the `grpclb` load balancing policy is
in use; it will not work with client-side policies like `round_robin`.

Also, note that in case 1, the client will not have access to the
service config for the server name.  This is not a problem in cases 2
and 3, where the service config data will be available as expected via
the resolver.

## Rationale

The proposed design allows two different ways of triggering use of
the HTTP CONNECT handshaker code, which addresses the needs of the
environments described above.

Note that another alternative for case 3 would be to use a gRPC-level
proxy instead of a TCP-level proxy, where the proxy natively speaks gRPC.
The idea is that the proxy accepts a gRPC request from the external client
and then uses its own client on the internal side, which does the name
resolution and per-call load balancing internally to the backend servers.
The trade-off here is that this approach requires that the gRPC-level
proxy be trusted by all internal servers, which has security implications
(e.g., a successful attack on the proxy would yield priviledged access
on all internal servers).

## Implementation

In C-core, the HTTP CONNECT handshaker was already implemented.
The following additional changes have also been made:

- [grpc/grpc#9383](https://github.com/grpc/grpc/pull/9383) (changes
  HTTP CONNECT handshaker to be triggered via channel args)
- [grpc/grpc#9372](https://github.com/grpc/grpc/pull/9372) (adds proxy
  mapper hook)

## Open issues (if applicable)

N/A
